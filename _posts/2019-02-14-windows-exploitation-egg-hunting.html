---
layout: post
title: 'Windows Exploitation: Egg hunting'
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/579/1*EXyOLLOWYODOpxc7pI-7Xw.png" /></figure>
<p>Lately, I’ve been exploring the world of Windows exploitation. I was already familiar with the concept of Buffer
    Overflows, brushed those skills up during OSCP days and now I’m taking steps further. One thing I have noticed in
    this world is that size of your payload matters, simply because we don’t get the luxury of thousands of bytes of
    available space to play with everytime. Egg hunting is one such technique that helps in those cases. Before you jump
    in, I am assuming you already have a background in Buffer Overflows, if not please spend some time in understanding
    the tidbits of BOs first before jumping on to this topic.</p>
<h4>Staged payloads</h4>
<p>To aid with the size of payloads, Metasploit already has a concept of ‘staged payloads’. These payloads work in 2
    stages. First stage, relatively small, will connect back to attacker’s system. Metasploit then transfers the stage 2
    which contains the meat of the payload, the actual shellcode which will give us a command/meterpreter shell. Here is
    the comparision between the size of staged and unstaged payloads:</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*UHeQZoF99H2FeI4-tXR66g.png" />
    <figcaption>Size comparison for meterpreter shell</figcaption>
</figure>
<p>The first command is generating staged payload (meterpreter/reverse_tcp), second one unstaged
    (meterpreter_reverse_tcp). There is a huge difference in size of those payloads- 341 bytes vs 179779 bytes. While
    341 bytes seems very small in comparison, it may still be too large. Plus, staged payloads are not always helpful:
</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1002/1*G4ihnWwm8z8EBBVMPaUjNw.png" />
    <figcaption>Size comparison for command shell</figcaption>
</figure>
<p>But the concept of staged payloads is certainly interesting. What if we can execute our shellcode in small stages?
    Let me introduce you to Egg hunting now.</p>
<h4>Egg hunting</h4>
<p>Egg hunting is a technique in which we use an <strong>egg hunter</strong> to <em>hunt</em> for the actual payload,
    which is marked by an <strong>egg</strong>. Confused? Let’s break this down in points:</p>
<ol>
    <li>We will be using two shellcodes in this technique- one is the <strong>egg hunter</strong> and other is the
        <strong>payload</strong> we want to execute.</li>
    <li>Payload is marked with a unique tag called <strong>egg</strong>. We generally select a 4 character egg and
        repeat it twice for marking our payload. Why? As you’ll discover later, it is for optimizing size of egg hunter.
        So if our egg is nope and our payload is \x90\x90\x90\x90, our final payload will look like:<br>payload =
        &quot;nopenope&quot; + &quot;\x90\x90\x90\x90&quot;</li>
    <li>Egg hunter is a special shellcode that searches for the provided egg in the memory and run the payload marked by
        it. It’s very small in size. This egg hunter is the shellcode that you will be running after the overflow.</li>
</ol>
<p>So, earlier we used to have a buffer like this while performing buffer overflow:</p>
<p>buf = &quot;A&quot;*[offset] + [JMP ESP] + [NOP Sled] + [Shellcode]</p>
<p>Now, with egg hunting you’ll have these:</p>
<pre>payload = &quot;nopenope&quot; + [Shellcode]</pre>
<pre>buf = &quot;A&quot;*[offset] + [JMP ESP] + [NOP Sled] + [EggHunter(&#39;nope&#39;)]</pre>
<p>An important thing to note here is that when the program will be executing the EggHunter, the payload must already be
    there in the memory, otherwise the egg hunter will keep searching the memory and spike the CPU to 100%.</p>
<p>It would now be a good time to read the most awesome resource for egg hunting- <a
        href="http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf">Skape’s paper</a>. Since we are sticking to
    Windows in this article, I will only focus on techniques related to Windows.</p>
<p>Skape’s paper highlights two methods:</p>
<ol>
    <li><strong>Using SEH</strong>- By registering our own exception handler that performs the hunting. Size is
        60 bytes.</li>
    <li><strong>Using syscalls</strong>- IsBadReadPtr or NtDisplayString functions are used for hunting. IsBadReadPtr is
        37 bytes and NtDisplayString is 32 bytes.</li>
</ol>
<p>I’m not going into technical details of how these methods work otherwise I’ll just end up repeating Skape’s paper,
    better go ahead and read that first. What I can do here is repeat the code Skape used in his NtDisplayString method
    (can be found <a href="http://www.hick.org/~mmiller/shellcode/win32/egghunt_syscall.c">here</a>):</p><iframe src=""
    width="0" height="0" frameborder="0" scrolling="no"><a
        href="https://medium.com/media/4d238a068ab18ce9f08f28cd1833639e/href">https://medium.com/media/4d238a068ab18ce9f08f28cd1833639e/href</a></iframe>
<p>The hex equivalent of this code would look something like this:</p>
<pre>Hex                     Instruction<br>6681CAFF0F              OR DX,0FFF<br>42                      INC EDX<br>52                      PUSH EDX<br>6A02                    PUSH 00000002<br>58                      POP EAX<br>CD2E                    INT 2E<br>3C05                    CMP AL,05<br>5A                      POP EDX<br>74EF                    JE 00000100<br>B86E6F7065              MOV EAX,65706F6E # 0x6e6f7065 = &quot;nope&quot;<br>8BFA                    MOV EDI,EDX<br>AF                      SCASD<br>75EA                    JNE 00000105<br>AF                      SCASD<br>75E7                    JNE 00000105<br>FFE7                    JMP EDI</pre>
<p>If you look closely, the code seems to be using NtAccessCheckAndAuditAlarm, not NtDisplayString. Both of them
    function in same way, the only difference is syscall number so no need to worry about that. If you want to see the
    above code in action, you can go through <a
        href="http://www.securitysift.com/windows-exploit-development-part-5-locating-shellcode-egghunting/">Security
        Sift’s blog</a> which does a wonderful job of stepping through each line to explain its working.</p>
<h4>Exploitation</h4>
<p>We’ll be exploiting <strong>PMSoftware Simple Web Server 2.2-rc2</strong> for demonstration. It is a simple HTTP
    server which had a buffer overflow vulnerability in <strong>Connection</strong> HTTP header. The original exploit is
    discussed <a
        href="https://ghostinthelab.wordpress.com/2012/07/19/simplewebserver-2-2-rc2-remote-buffer-overflow-exploit/">here</a>.
    We also have a <a href="https://www.rapid7.com/db/modules/exploit/windows/http/sws_connection_bof">metasploit
        module</a> for this one:</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/857/1*h8hVpQzj2S30S1aqspenXw.png" />
    <figcaption>Metasploit module</figcaption>
</figure>
<p>Let’s write an exploit of our own using Egg hunting technique. Considering Connection header is vulnerable, the
    skeleton code to perform the overflow would look like:</p><iframe src="" width="0" height="0" frameborder="0"
    scrolling="no"><a
        href="https://medium.com/media/6bc59dcb1c7c2be0b9e736b03bcd4d97/href">https://medium.com/media/6bc59dcb1c7c2be0b9e736b03bcd4d97/href</a></iframe>
<p>Here’s how that overflow would look like:</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/830/1*eH8T1ldVPxSJ0PlkSaZsqQ.png" />
    <figcaption>Replicating the crash</figcaption>
</figure>
<p>To find the exact number of bytes after which EIP is getting overwritten, we will send the Metasploit pattern. The
    offset comes out to be 2048 bytes.</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/830/1*zPwlYoNGL6KcqhI6GVPNKA.png" />
    <figcaption>Finding offset</figcaption>
</figure>
<p>And, we quickly get the JMP ESP sorted out too:</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/635/1*mUc0oilrar0h_XTR-5WVTg.png" />
    <figcaption>Finding JMP ESP</figcaption>
</figure>
<p>Time to generate some venom! Since we are doing this the egg hunting way, the shellcode variable in my skeleton code
    would contain the hex version of egg hunter. So, for egghunter I have used the hex equivalents (opcodes) mentioned
    above, but !mona egghunter can also generate it for you (as shown in opening image of this blog). There will be
    another variable payload that would contain the venom with a prefix of egg being repeated twice. But I have to
    ensure the payload is already there in the memory while egghunter is getting executed. For that, I’ll be sending
    payload as part of the <strong>User-Agent</strong> header. Enough talk, here is the code:</p><iframe src=""
    width="0" height="0" frameborder="0" scrolling="no"><a
        href="https://medium.com/media/dd6910a598cfdbe93d7a301cc1987cb8/href">https://medium.com/media/dd6910a598cfdbe93d7a301cc1987cb8/href</a></iframe>
<p>The data being sent here has payload in <strong>User-Agent</strong> header and exploit in the vulnerable
    <strong>Connection</strong> header. The exploit variable is executing egghunter on overflow. payload variable
    contains the shellcode and will be there in memory, waiting for the egghunter.</p>
<p>After running this code, there will a spike in CPU and in a minute or two you can notice that our payload gets
    executed:</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/444/1*YHJRMwuWK2YlOB8QtmGieA.png" />
    <figcaption>Shell from our test machine</figcaption>
</figure>
<p>Great! What now? There is a very interesting possibility that the payload may end up in multiple places in the
    memory, and some copies of it can contain incomplete/overwritten shellcode. So, how can we ensure that the shellcode
    attached with the egg is in its entirety? How can we ensure the integrity of our shellcode before we start executing
    it? This problem was tackled in <a
        href="http://www.securitysift.com/windows-exploit-development-part-5-locating-shellcode-egghunting/">Security
        Sift’s blog</a> under section <strong>Overcoming Corrupted Shellcode- The Egg Sandwich</strong>. The author has
    discussed multiple options there, but the egg sandwich method was the one that I found most neat and elegant.</p>
<p><strong>Conclusion</strong></p>
<p>This blog was not meant to be a comprehensive guide of Egg hunting. The purpose was to introduce you to Egg hunting.
    I would encourage you to try exploiting it on your own and then jump onto much more detailed blogs like the one from
    <a href="https://www.corelan.be/index.php/2010/01/09/exploit-writing-tutorial-part-8-win32-egg-hunting/">Corelan
        Team</a>. Happy hunting, happy cracking! :)</p><img
    src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=117828020595" width="1"
    height="1">