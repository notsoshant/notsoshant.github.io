---
layout: post
title: 'Windows Exploitation: ASLR Bypass (MS07–017)'
---

<p>In this blog, I will be analysing a long forgotten Windows Animated Cursor Remote Code Execution Vulnerability (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2007-0038">CVE-2007–0038</a>) on Windows Vista. It was a classic case of a random not being random enough. A bit of a backstory before we move on…</p><p>Few days back while scrolling Twitter, I found this amazing story about inception of ASLR from <a href="https://twitter.com/JohnLaTwC">John Lambert</a>, a cool guy from Microsoft Threat Intelligence Center.<br>(Follow him, and *shameless grin* <a href="https://twitter.com/notsoshant">follow me</a> too)</p><style>body[data-twttr-rendered="true"] {background-color: transparent;}.twitter-tweet {margin: auto !important;}</style><blockquote class="twitter-tweet" data-conversation="none" data-align="center" data-dnt="true"><p>Story time. This one is about a feature in Windows called ASLR.</p><p>&#x200a;&mdash;&#x200a;<a href="https://twitter.com/JohnLaTwC/status/1093956949073289216">@JohnLaTwC</a></p></blockquote><script src="//platform.twitter.com/widgets.js" charset="utf-8"></script><script>function notifyResize(height) {height = height ? height : document.documentElement.offsetHeight; var resized = false; if (window.donkey && donkey.resize) {donkey.resize(height);resized = true;}if (parent && parent._resizeIframe) {var obj = {iframe: window.frameElement, height: height}; parent._resizeIframe(obj); resized = true;}if (window.location && window.location.hash === "#amp=1" && window.parent && window.parent.postMessage) {window.parent.postMessage({sentinel: "amp", type: "embed-size", height: height}, "*");}if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.resize) {window.webkit.messageHandlers.resize.postMessage(height); resized = true;}return resized;}twttr.events.bind('rendered', function (event) {notifyResize();}); twttr.events.bind('resize', function (event) {notifyResize();});</script><script>if (parent && parent._resizeIframe) {var maxWidth = parseInt(window.frameElement.getAttribute("width")); if ( 500  < maxWidth) {window.frameElement.setAttribute("width", "500");}}</script><p>And while you are at it, you just <em>might </em>want to look at this thread to understand why Windows Vista was not wrong, just ahead of time:</p><style>body[data-twttr-rendered="true"] {background-color: transparent;}.twitter-tweet {margin: auto !important;}</style><blockquote class="twitter-tweet" data-conversation="none" data-align="center" data-dnt="true"><p>Today is Windows Vista&#39;s End Of Life for updates and support.</p><p>&#x200a;&mdash;&#x200a;<a href="https://twitter.com/SwiftOnSecurity/status/851857404891471872">@SwiftOnSecurity</a></p></blockquote><script src="//platform.twitter.com/widgets.js" charset="utf-8"></script><script>function notifyResize(height) {height = height ? height : document.documentElement.offsetHeight; var resized = false; if (window.donkey && donkey.resize) {donkey.resize(height);resized = true;}if (parent && parent._resizeIframe) {var obj = {iframe: window.frameElement, height: height}; parent._resizeIframe(obj); resized = true;}if (window.location && window.location.hash === "#amp=1" && window.parent && window.parent.postMessage) {window.parent.postMessage({sentinel: "amp", type: "embed-size", height: height}, "*");}if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.resize) {window.webkit.messageHandlers.resize.postMessage(height); resized = true;}return resized;}twttr.events.bind('rendered', function (event) {notifyResize();}); twttr.events.bind('resize', function (event) {notifyResize();});</script><script>if (parent && parent._resizeIframe) {var maxWidth = parseInt(window.frameElement.getAttribute("width")); if ( 500  < maxWidth) {window.frameElement.setAttribute("width", "500");}}</script><p>OK, no more threads. And yes, you have every right to hate Vista, or hate Windows. The reason why I started with the story of ASLR and then Windows Vista is that many people out there remember <a href="https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2007/ms07-017">MS07–017</a> as a <em>slap on the face of Windows Vista’s security</em> when it clearly is not the case. Yes, researchers were able to bypass the protections (ASLR) in Windows Vista, but these protections didn’t even exist in XP in the first place! Advising users to roll back to XP was plain stupid!</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2FZv6Apawffpa2k%2Ftwitter%2Fiframe&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2Fmarilyn-monroe-gif-Zv6Apawffpa2k&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2FZv6Apawffpa2k%2F200.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy" width="435" height="257" frameborder="0" scrolling="no"><a href="https://medium.com/media/35265ee05267c4bad0f6734e158405a0/href">https://medium.com/media/35265ee05267c4bad0f6734e158405a0/href</a></iframe><p>With this misconception out of our way, let’s move forward and understand the vulnerability first. For that, we need to understand how ANI files work.</p><h3>The ANI files</h3><p>The vulnerability lies in the way ANI headers are handled in Windows. So what are ANI files? <a href="https://en.wikipedia.org/wiki/ANI_(file_format)">ANI files</a> are animated mouse cursors that are used by Windows. These files follow the <a href="https://en.wikipedia.org/wiki/Resource_Interchange_File_Format">RIFF file format</a> that was developed by IBM and Microsoft. I’m not going to delve into a lot of details of how RIFF works, will keep it limited to the knowledge we would need.</p><h4>RIFF File Format</h4><p>RIFF file format stores data in chunks. For ANI files, there are mainly two types of chunks- <strong>anih</strong> and <strong>LIST</strong>. <strong>anih</strong> (ANI Header) chunk stores the metadata about the file and <strong>LIST</strong> stores the actual data. Here is an example of an animated cursor:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/878/1*ss74YGKBpopoyoJpexghrA.png" /><figcaption>ANI File Format</figcaption></figure><p>The bytes marked with-<br><strong>Red</strong>: “RIFF” itself. Indicates the file follows RIFF file format.<br><strong>Orange:</strong> The length of rest of the file<br><strong>Yellow:</strong> “ACON”. The header ID. Indicates the file is ANI file.<br><strong>Green:</strong> “anih”. Denotes the beginning of anih chunk.<br><strong>Blue:</strong> Size of chunk. 0x24 or 36 bytes.<br><strong>Purple:</strong> Rest of the anih chunk.</p><p>After the anih chunk, there is a LIST chunk (like anih chunk, its size is in next 4 bytes and the data thereafter) but we are interested in anih chunks only. If you want to know about what all data is stored in ANI header (the purple part), you can look at <strong>Structure of the ‘anih’ header chunk</strong> section <a href="http://www.daubnet.com/en/file-format-ani">here</a>. Enough background for now.</p><h3>The Vulnerability</h3><p>Windows uses a function LoadCursorIconFromFileMap to use ANI files. It didn’t validate the size of anih chunks, anything above 36 bytes lead to an overflow, and Microsoft fixed this in <a href="https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2005/ms05-002">MS05–002</a>. In the patch, the function started validating the anih header size to make sure it is 36 bytes only. Unfortunately, it was only validating the first anih chunk.</p><p>LoadCursorIconFromFileMap function internally calls LoadAniIcon which loads all the chunks. LoadAniIcon function do not validate size of any chunk. So, if an ANI file is having two anih chunks, the first one being valid 36 bytes header and second one being fatty malicious one, will bypass the mitigations of MS05–002 and will result in overflow in LoadAniIcon function.</p><h4>Proof of Concept code</h4><p>The researcher who found this vulnerability released a <a href="https://web.archive.org/web/20070701070839/http://www.determina.com/security.research/vulnerabilities/ani-header.html">PoC ANI file</a> which replicates this overflow:<br>(You can use <a href="https://gist.github.com/notsoshant/1ae8ee227314d7a735be0be5d42c24d7">this</a> python script to create this file yourself)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/617/1*kQHxvEdkrw_08pWTu_iZBQ.png" /><figcaption>MS07–017 PoC ANI file</figcaption></figure><p>In this PoC we can observe two anih chunks. First one is perfectly valid healthy 36 bytes chunk. Second chunk is a fatty 88 byte (or 0x58 bytes) anih chunk which will lead to an overflow. For those of you who are wondering why we have random nulls in second chunk, read the comments in line 476–488 of the <a href="https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/windows/browser/ms07_017_ani_loadimage_chunksize.rb">metasploit module</a> of this vulnerability.</p><p>But how will we deliver this payload? We will have to make Windows load this ANI file for that. There are multiple ways of doing it but best case scenario would be to deliver this ANI file <em>remotely</em> to the system. That way we will have a remote code execution! We can make victim open a malicious webpage, webpages can define custom cursors. Or we can send an HTML formatted mail to the victim. All you have to do is create a webpage with following code:</p><pre>&lt;html&gt; &lt;body style=&quot;cursor: url(&#39;exploit.ani&#39;)&quot;&gt; &lt;/html&gt;</pre><p>Let’s see this PoC in action:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/799/1*PqQFW23vg38t9d2dQfq-3A.png" /></figure><p>Great! PoC works. But a curious mind would question WHY. This is Windows Vista. The program must have been compiled with Stack Canary (GS flag). But nope, it wasn’t. Compiler chose not to. As it will turn out later, DEP is also disabled for Internet Explorer. If you want to learn more about why these protections were absent, have a look at <a href="http://uninformed.org/index.cgi?v=9&amp;a=4&amp;p=14">Matt Miller’s analysis</a> of this vulnerability.</p><h4>The exploitation</h4><p>So we have 43434343 written in EIP. How about finding a JMP ESP now? But hold your horses. We have ASLR enabled here in Windows Vista. Even if we find an address to JMP ESP, it’ll get changed after we restart the system. Right… RIGHT? Well, sort of. The address indeed will change, but only the first two bytes. Here’s an example:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/481/1*CrKA6DbV_tW3YUdExq-rfQ.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/483/1*9aE2Cm8z0XPT13yYtQeq0Q.png" /><figcaption>ASLR in action</figcaption></figure><p>Note the address of JMP ESP in first image. And then look at it in second image. You can see the difference ASLR is making- changing only first two bytes while keeping last two constant.</p><p>Because of the way stack is laid out, when our exploit would be overwriting the value of EIP, it would first be overwriting the fourth byte, then the third byte, then the second byte and finally the first byte. This means that if we overwrite only two bytes in EIP, we would overwrite the last two bytes. Let’s replicate this first. We would modify our PoC to only overwrite 4343, not 43434343.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/616/1*ihaROnMpO8MGswyCl_tMfw.png" /><figcaption>Modified PoC</figcaption></figure><p>Note that I have modified the size of RIFF and second anih chunk too (highlighted in yellow). After using this ANI file, this was the overwrite we’ll get:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/799/1*-i6UNChFVzA7w24Gmvhtiw.png" /><figcaption>EIP with 2 bytes overwritten</figcaption></figure><p>Great! Now we have to find a JMP ESP in the range of 77B5XXXX. Why? Let’s say we found a JMP ESP at 77B57A90. Now, even if the system restarts, this JMP ESP will shift to let’s say 76A17A90 or 77B17A90 or 749B7A90, the last two bytes are always constant aaaand our exploit will overwrite just these two bytes.</p><p>So we start searching the 77B5XXXX range for JMP ESP, but no luck. Looking at other registers, we do have a JMP [EBX] instruction in the range:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/368/1*bbd49Dvx7ZJmZ2Zq1tjIEg.png" /><figcaption>JMP [EBX]</figcaption></figure><p>And EBX looks interesting too. It holds the address of the beginning of our ANI file.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*9_kJbZGS1YYrvey5J_QveQ.png" /><figcaption>The EBX register</figcaption></figure><p>From Registers pane, we see EBX holds value 02BFF0EC which point to value 02D50000. In the dump, we can see the value at 02D50000, it points to our ANI file. If we look at our file as instructions in Instructions pane, that “RIFF” would convert to weird (but safe) instructions.</p><p>Before proceeding further let’s verify if our theory of jumping to beginning of our ANI file is working or not. We can safely replace the 4 bytes after “RIFF” with anything. So let’s put an INT3 instruction there. Here is how our ANI file would look like:<br>(Code for creating this file is <a href="https://gist.github.com/notsoshant/dc0d9dbf6f28ebb93e2a5ae700df1e68">here</a>)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/622/1*M77NCcw-F8KtvhQ99jF6Qw.png" /><figcaption>ANI file to verify JMP [EBX]</figcaption></figure><p>The EIP will be overwritten with 700b, which should point to JMP EBX. Let’s put a breakpoint at this instruction to verify.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*v71INxB_KFnA5GF7OP7XsA.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/799/1*Ocw_VQXOP6fn-F09sP8DtQ.png" /><figcaption>The JMP [EBX]</figcaption></figure><p>As we can see here, we did hit our breakpoint at JMP [EBX] and then started <em>executing</em> our ANI file. But how and where do we put our payload? We can only use the 4 bytes after “RIFF”, we cannot overwrite “ACON” and anih chunk after that. What we can do is place our payload after valid anih chunk and place a short jump in bytes after “RIFF” to jump to the payload. Currently, our ANI file is looking like this:</p><pre>RIFF + size + ACON + valid_anih + exploit_anih</pre><p>We can do something like this:</p><pre>RIFF + [JMP payload] + ACON + valid_anih + payload + exploit_anih</pre><p>Time for some venom! The code for generating our final ANI file:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d270972f5e65a578fc22a667b14b309b/href">https://medium.com/media/d270972f5e65a578fc22a667b14b309b/href</a></iframe><p>And this is our final ANI file:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/614/1*1T_08Yn3yUlPICcmUj32pQ.png" /><figcaption>Final ANI file</figcaption></figure><p>With this ANI file in place, we finally have a this:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/932/1*CNdynSK7-bg0_X0qd-yO2A.png" /><figcaption>Meterpreter session</figcaption></figure><p>Oh, yeah!</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fgiphy.com%2Fembed%2FXqXDNFZREKMBq%2Ftwitter%2Fiframe&amp;url=https%3A%2F%2Fgiphy.com%2Fgifs%2Frastamouse-XqXDNFZREKMBq&amp;image=https%3A%2F%2Fmedia.giphy.com%2Fmedia%2FXqXDNFZREKMBq%2F200.gif&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=giphy" width="435" height="344" frameborder="0" scrolling="no"><a href="https://medium.com/media/fb4f3ce8e1e1e1becf3126f75a5ba59d/href">https://medium.com/media/fb4f3ce8e1e1e1becf3126f75a5ba59d/href</a></iframe><h3>Further Reading</h3><ul><li><a href="https://web.archive.org/web/20070701070839/http://www.determina.com/security.research/vulnerabilities/ani-header.html">Determina Security Research’s article</a></li><li>SANS White Paper- <a href="https://www.sans.org/reading-room/whitepapers/threats/ani-vulnerability-history-repeats-1926">ANI Vulnerability: History repeats</a></li><li>Matt Miller’s <a href="http://uninformed.org/index.cgi?v=9&amp;a=4&amp;p=13">Case Study of MS07–017</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8760378e3e84" width="1" height="1">
