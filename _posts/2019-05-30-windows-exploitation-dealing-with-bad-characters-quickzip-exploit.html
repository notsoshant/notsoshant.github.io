---
layout: post
title: 'Windows Exploitation: Dealing with bad characters — QuickZip exploit'
---

<h3>Windows Exploitation: Dealing with bad characters — QuickZip exploit</h3><p>When you begin your journey in exploitation, you start with simple buffer overflows, then you deal with SEH, play with egg hunters and so on. The process of exploitation is pretty straightforward in this journey- sending a pretty large cyclic pattern, figuring out the offset to EIP in order to control it, then passing the address to JMP ESP or POP POP RET or other gadgets which ultimately will execute our shellcode.</p><p>However, perhaps the most undervalued step in this journey would have been finding bad characters. And I understand why. Most of the time the bad characters situation is easily dealt with using an encoder. But what if the number of bad characters is greater than good ones? That’s when things get tricky. Suddenly this seemingly insignificant step becomes a huge pain and affects every other step of exploit development. QuickZip 4.60 was a similar kind of story that is discussed in detail by corelanc0d3r <a href="https://www.offensive-security.com/vulndev/quickzip-stack-bof-0day-a-box-of-chocolates/">here</a>, which is also I’m about to do. BUT, the method I’m about to use is slightly different (not claiming it to be better or worse, just different) than the one (actually two) discussed there. So, let’s get started.</p><h3>Finding the offset</h3><p>Before I begin, the environment I’m going to use will be a Windows Vista x86, the original article was written for Windows XP SP3 environment so you might notice some differences in the offsets and addresses.</p><h4>The crash!</h4><p>I will jump straight to the PoC code that I copied from the article in order to replicate the crash.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a1d72e3a1fd29ee83f9baaf87731e0ac/href">https://medium.com/media/a1d72e3a1fd29ee83f9baaf87731e0ac/href</a></iframe><p>This PoC will create an <strong>exploit.zip</strong> file which needs to be opened using QuickZip. Double-clicking on the filename will result in the crash.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/679/1*qSsdCZrfjq-kfzA8SYhU9Q.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/634/1*pzv2yqMUmYNi_lfBRXq4xg.png" /><figcaption>The crash</figcaption></figure><p>Interestingly, the crash doesn’t look exploitable, there’s no cyclic pattern in EIP or SEH chain.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/636/1*daiZ3-hSlynTheacJvunUg.png" /><figcaption>SEH chain</figcaption></figure><p>But if we pass the exception using <strong>Shift + F9</strong>, we can observe the SEH chain pops up with the pattern.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/264/1*p1NYE-7RFbuL4fF4V_Vm6A.png" /><figcaption>After passing the exception</figcaption></figure><h4>The offset</h4><p>Alright. From the address <strong>396A4138</strong>, we can deduce the offset of <strong>296</strong> bytes. Let’s confirm it first. We’ll modify the payload a bit:</p><pre>payload = &quot;A&quot;*296 + &quot;B&quot;*4 + &quot;C&quot;*4 + &quot;D&quot;*(4064-296-8)</pre><p>We’ll recreate the malicious ZIP file and get a crash like this which confirms our offsets.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/397/1*dMvir6RdnxaPwBd9WbQdNw.png" /><figcaption>Confirming offset</figcaption></figure><p>Now comes the brutal part. Finding the bad characters. Mona.py from corelanc0d3r will help us a lot here. Since we are putting our payload in filename, we can do some guess work to predict some bad characters. Characters like / \ : should be in bad char list. But let me demonstrate a simple procedure which uses <strong>mona.py</strong> to ease out the process of finding bad characters.</p><h3>Using mona.py to find bad chars</h3><p>To find bad characters, we will send an array of all possible characters as part of the payload. Then we’ll use mona.py to compare the array with the memory.</p><h4>Generating the array</h4><p>To create the array, you can use !mona bytearray command. This will print the array in Immunity Debugger’s log, and also create files <strong>bytearray.txt</strong> and <strong>bytearray.bin</strong>. You can copy the array from the <strong>bytearray.txt</strong> file, the <strong>bytearray.bin</strong> file will be used in comparison later.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/607/1*_01HGCsoRp0JapeOg28uXQ.png" /><figcaption>Generating bytearray</figcaption></figure><p>For a quick reference, these oneliners can also be used to generate the array:</p><pre><strong>Python</strong><br>for i in range(0,256): print(&#39;\\x%02X&#39; % i, end=&#39;&#39;)</pre><pre><strong>Bash</strong><br>for i in {0..255}; do printf &quot;\\\x%02x&quot; $i;done</pre><p>We’ll modify our PoC code to generate the ZIP file with our bytearray. After modification, our code should look something like this:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/98e2566b616e47eda2983fbe7a644007/href">https://medium.com/media/98e2566b616e47eda2983fbe7a644007/href</a></iframe><h4>Let’s hunt for bad chars!</h4><p>We’ll run the generated ZIP through QuickZip and see what happens.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/200/1*dN1XQEKJ6XcSFNWZfBWx-Q.png" /><figcaption>Truncation after NULL</figcaption></figure><p>Right off we see that the \x00 is causing problems. Let’s recreate the ZIP after removing it and repeat the process.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/679/1*levfgMCsNcDh2VJEvVYUvg.png" /><figcaption>No files being listed</figcaption></figure><p>Woah! What just happened? Looking at Immunity, we do see few registers pointing at our payload. Following it on dump shows some interesting things. \x0F ,\x14, \x15 and \x2F are mangled and everything after \x3A is truncated. It makes sense though, \x3A is colon (:) character, a filename containing colon is expected to have everything after it truncated.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/633/1*PO7GT_ffTj-cjl7oomW1vQ.png" /><figcaption>Mangled bytearray in memory</figcaption></figure><p>But visually identifying mangled characters is pain and it leaves a lot of room for errors. I mean, I missed \x14 and \x15 myself. That’s why we’d like an automated way to find these differences and mona will help us here. Just pass the following command to mona:</p><pre>!mona compare -f bytearray.bin -a [address where array begins]</pre><p>Here is the output of this command in above case:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/535/1*DH9yP-bcyEdR4cCtu-tUkw.png" /><figcaption>!mona compare output</figcaption></figure><p>We can see how beautifully mona helps us with the bad chars. We’ll repeat this process after removing bad chars. This time our payload is being treated as a folder instead of file:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/370/1*33k06WJwebI1g7K1OORpOA.png" /><figcaption>Payload as folder</figcaption></figure><p>And gives out an error on double clicking too:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/479/1*vhGJuCROEhzCQ0eoZHrmkQ.png" /><figcaption>Error message on double click</figcaption></figure><p>If we closely look at the error message, we can figure out the error happened around \ character which also makes sense and explains why our payload was being treated as a folder. We’ll remove \ or \x5C from our array and try again. This time we’ll get a clean crash. A quick look at the comparison and WHAT A HORROR STORY WE HAVE!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/572/1*G7nu2Ud4lRpgzetMgDPXSA.png" /><figcaption>Comparison with bytearray</figcaption></figure><p>Every character after \x80 is mangled! Not missing, it’s mangled! It’s different from the crash we had with \x3A, the contents got truncated after that character. Here every character is getting converted to something, every character after \x80 is bad! The final list of bad chars is:</p><pre><strong>Bad chars</strong>:<br>\x00\x0F\x14\x15\x2F\x3A\x5C\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF</pre><h3>THE exploit development</h3><p>Now that we have more than half of all characters as bad, let’s figure out how can we proceed further.</p><h4>POP POP RET</h4><p>The first step in SEH exploitation is to find a suitable POP POP RET address. Looking at the loaded modules, we can only find the QuickZip.exe itself without SafeSEH.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/650/1*kOEVTHIjHOgqq0ZZeFzYeQ.png" /><figcaption>Modules without SafeSEH</figcaption></figure><p>The base address of that module doesn’t look very promising though, we immediately face a pretty big challenge. All the addresses from this module will have a NULL byte at the beginning. But let’s ignore it for now and pick one that doesn’t have other bad characters. One such address is <strong>0x00407A33</strong>. Let’s verify if this address is really working. We’ll modify our payload to something like this:</p><pre>payload = &quot;A&quot;*296 + &quot;B&quot;*4 + &quot;\x33\x7A\x40\x00&quot; + &quot;D&quot;*(4064-296-8)</pre><p>Recreate the ZIP. Open it with QuickZip. Double click on filename. And we have <strong>0x00407A33</strong> listed in SEH chain.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/419/1*AtfZQs1nQkL3GlWnIS4KMQ.png" /><figcaption>POP POP RET in SEH chain</figcaption></figure><p>Let’s set a breakpoint at <strong>0x00407A33</strong> and verify POP POP RET too.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/641/1*AT_vLX6y7Qv-uhUObWsXLQ.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/465/1*-SVruLWfDQhU22P44mJqRw.png" /><figcaption>Verifying POP POP RET</figcaption></figure><p>Perfect! Sad thing to notice here is that all our <strong>D</strong>s are truncated.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/266/1*gPrV1ff7XAeOsTbztomB9Q.png" /><figcaption>Truncated payload after address</figcaption></figure><h4>Jump! Eh, how?</h4><p>Now that we have a working POP POP RET, how do we jump? Our good old \xEB is among bad chars. Plus, we’ll have to perform a negative jump as everything after the address is truncated, the only place left for shellcode is the starting 296 bytes. And negative jump means using a value from \x80 to \xFF, all of them are bad chars.</p><p>We can resolve the JMP issue by using any of the conditional jumps. Instead of me explaining it, you can go to <a href="https://www.corelan.be/index.php/2009/07/23/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-2/">this article</a> by corelanc0d3r, there’s a table at the bottom listing all the conditional jumps and their opcodes.</p><p>But what about the jump offset?</p><h4>Are bad chars really that bad?</h4><p>This is where my method starts to differ from method used by corelanc0d3r. We notice that almost every bad char is getting mangled to another character. The trick here is to leverage this conversion to un-bad the bad characters. Let’s look at the mangled bytearray again.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/572/1*G7nu2Ud4lRpgzetMgDPXSA.png" /><figcaption>Mangled bytearray</figcaption></figure><p>We can notice here that \x87 is getting mangled to \xE7. So, if we want \xE7 in our shellcode, we’d use \x87 instead and QuickZip will convert it to \xE7 for us. And wait a minute, we have \xEB among <em>possibly-good</em> chars too, we can use it instead, no need for conditional jumps!</p><p>Let’s test this theory and perform a negative jump. We will use \x89\xF6 which should give us \xEB\xF7 in memory, and it translates to JMP 0xF7 or ‘Jump back 7 characters’ (remember, offset is counted <em>considering</em> the length of JMP instruction itself). We’ll modify our payload to look something like:</p><pre>payload  = &quot;A&quot;*(296-7) + &quot;B&quot;*7 + &quot;\x89\xf6\x41\x41&quot; # JMP 0xF7<br>payload += &quot;\x33\x7A\x40\x00&quot; + &quot;D&quot;*(4064-296-8)</pre><p>Our JMP should take us at the beginning of <strong>B</strong>s. Let’s see what happens.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/466/1*gq1qZVmkVBTkQkQNXkp8JQ.png" /><figcaption>JMP 0xF7</figcaption></figure><p>Excellent! We can see we can our JMP instruction and the resulting jump here. Our theory is working properly and we’ll be using it extensively in future.</p><p>Using our theory, we can quickly eliminate many <em>possibly-good</em> chars from bad char list. Our list effectively becomes:</p><pre><strong>Bad chars</strong>:<br>\x00\x0F\x14\x15\x2F\x3A\x5C\x80\x81\x82\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA4\xA7\xA8\xA9\xAD\xAE\xB3\xB4\xB6\xB8\xB9\xBE\xC0\xC1\xC2\xC3\xC8\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD2\xD3\xD4\xD5\xD7\xD8\xD9\xDA\xDB\xDD\xDE\xE3\xF0\xF5\xF8\xFD\xFE</pre><p>Not as huge as before, but still a lot! At least enough to keep troubling us.</p><h4>Executing some code now</h4><p>So, we have a way to perform negative jumps now, but that still leaves us with only 296 bytes to execute our shellcode, that too without considering the jumps we’ll need. With the tight restrictions we have, standard shellcodes like bind or reverse shell would be very difficult to write. The encoders can help us, yes, but with so many bad chars, none of them would succeed. The best bet is using <strong>Alpha2</strong> encoder. After using <strong>BufferRegister</strong> to get pure alphanumeric shellcode (more on it <a href="https://www.offensive-security.com/metasploit-unleashed/alphanumeric-shellcode/">here</a>), the size of the payload becomes 710 bytes!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1016/1*G_VRDjmmHlHXCU3Zbm3pBw.png" /><figcaption>Shellcode with Alpha2 encoder</figcaption></figure><p>When we face issues with size of payload, the thing that immediately pops in our mind is an egghunter (huge props to Skape)! Encoding the egg hunter, we see:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1007/1*SNap7Jcg2TuvhsFUIIoQQw.png" /><figcaption>Egghunter with Alpha2 encoder</figcaption></figure><p>This looks <em>much</em> better. But the question is- where will we put the shellcode? It’s time to step back a bit and think, are the <strong>D</strong>s really getting truncated? If the application is loading the ZIP, the whole, unaltered ZIP may be there somewhere in memory. Let’s find it out.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/649/1*fGSLd-Gb_HdAiaoqRQt6zw.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/450/1*Ct1yFXXG2vE7eGlQROYDiQ.png" /><figcaption>Finding Ds</figcaption></figure><p>A quick search reveals the <strong>D</strong>s indeed are there in memory. However, none of the registers are pointing to this address, nor it is there in stack. That’s OK, egghunter was small enough to fit at the beginning of payload, we can use that. With an egghunter in place, our payload would look something like this:</p><pre>payload = <br>&quot;A&quot;*n + egghunter + &quot;JMP[egghunter]&quot; + POPPOPRET + [Egg + Shellcode]</pre><h4>The final hurdle</h4><p>While encoding our egghunter, we have to provide a <strong>BufferRegister</strong> otherwise the shellcode will contain bad chars. We provided a BufferRegister of EAX. That means the shellcode assumes it has address of itself stored in EAX register. How will we store the address of shellcode in EAX? This is where a CALL instruction would help us.</p><p>A CALL instruction pushes the next address in stack and jumps to the provided offset. We can then POP the address from stack into EAX. CALL instruction takes an offset of 4 bytes. If we have a positive offset the first 3 bytes would be \x00, not desirable. So, a negative offset makes sense since \xFF is not a bad char. We are looking at something like this:</p><pre>pop-eax: POP EAX<br>         JMP [hunter]<br>         NOP<br>         ...<br>         ...<br>call:    CALL [pop-eax]<br>hunter:  PUSH EAX<br>         ...<br>         ...<br>nseh:    JMP [call]<br>         INC ECX<br>         INC ECX<br>seh:     [POP POP RET]</pre><p>Time for some maths. A CALL instruction will take 5 bytes. Egghunter is 118 bytes. JMP instruction itself is 2 bytes. So, we need an offset of 125 bytes or 7D bytes. This translates to an offset of \x83. Good news is that \x83 is not a bad char.</p><p>Now, POP EAX takes 1 byte. JMP will take 2 bytes. So, any offset of 3 bytes or above will work. We have \xF7 available to us.</p><h4>Building THE exploit</h4><p>Final piece in the puzzle is our shellcode. We can encode the shellcode with same Alpha2 encoder. This time we will use EDI as <strong>BufferRegister</strong>, egghunter will already have the address stored in this register. You can use other encoders as well, since bad chars wouldn’t matter for shellcode. But you still need to consider \ / : as bad chars as these characters have special meaning for filenames.</p><p>Our final exploit should now look like:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d3b86a53ea035c054db8dd92ffbadd6e/href">https://medium.com/media/d3b86a53ea035c054db8dd92ffbadd6e/href</a></iframe><p>We’ll create our final ZIP, run it and boom!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/446/1*IEQvHuPfoAyQxRs6FUHuaQ.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/446/1*Oeu5TOigu1zPTIZHlcl0uQ.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/445/1*Z_MendnIE93X4Su1SvI2jA.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/446/1*UY61ITuUaM99zL8BEKO_qQ.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/448/1*8zCIi3HDrHdhKNnuzZsg4Q.png" /><figcaption>Exploit chain</figcaption></figure><p>We have a shell, oh yeah!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/622/1*38p1hR4X3CZc2PUy07_Spg.png" /></figure><h3>Conclusion</h3><p>I encourage you to rewrite the whole exploit with your own ideas. Corelanc0d3r’s article also encourages you to think and think hard. Try random stuff, break things. If you found a different method to exploit this then please share with us. Remember to always try harder!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=472db5251ca6" width="1" height="1">
